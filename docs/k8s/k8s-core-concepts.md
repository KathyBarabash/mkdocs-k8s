# Kubernetes Core Concepts

## Kubernetes Primitives

__Kubernetes__ is a container orchestrator acting as a desired state controller -- you define the desired state through the REST API and the system takes the necessary actions to achieve that desired state.

[k8s REST API](https://kubernetes.io/docs/concepts/overview/kubernetes-api/) archtecture has changed time. Initial API version, still available through /api/v1, was hard to extend. Current API architecture supports API groups and extensible through __CRDs__ (CustomResourceDefinitions). Current k8s API methods belong to one of the API groups and can be classified to one of the three maturity groups: _Alpha_, _Beta_, and _Stable_.  API Clients such as **kubectl** exist to convert consize commands to k8s API REST calls. 

### Objects

[k8s Objects](https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/) such as _pod_, _service_, _deployment_, etc. are persistent entities that represent both the desired and the actual state of the k8s system by containing two nested fields:
- The spec, provided by the end-user as YAML files
- The status, generated by the kubernetes control plane

There are three ways to [create k8s objects](https://kubernetes.io/docs/concepts/overview/working-with-objects/object-management/):
- Imperative commands:
    - `kubectl run nginx –image nginx`
- Imperative object configuration:
    - `kubectl create/delete/replace commands`
- Declarative object configuration:
    - `kubectl apply `

[Object names](https://kubernetes.io/docs/concepts/overview/working-with-objects/names/) have to be unique per object type per namespace but can be reused for different types and across namespaces. k8s generates an  historically unique UIDs for all the objects.
It is possible to get the UID of a resource, e.g.:
```
kubectl get pod captureorder-5d6fd597d4-jhdqf -o json | jq .metadata.uid
```

### Namespaces

[Namespaces](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/) are used to create multiple ‘virtual clusters’ on top of a single kubernetes cluster.

Most _kubectl_ commands are performed in a context of a default namespace. This can be changed by adding the `--namespace=xxx` flag. Commands addressing all the namespaces require the `--all-namespaces` flag.

To see what is the default namespace, run `kubectl config view | grep namespace`.

To set the default namespace, run `kubectl config set-context --current --namespace=xxx`.

Namespaces are also important for the default DNS resolution. k8s creates DNS entry for k8s services in the form of `service.namespace.svc.cluster.local`. To reach services in a different namespaces, one has to specify this FQDN rather than just the service name.

### Labels, selectors and annotation

k8s supports [labels and selectors](http:// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/) to organize objects into sets. 
To create a service linked to a certain deployment, it is possible to label the deployment and specify this label as a selector in the service definition, e.g.:

__Deployement__ 
```
apiVersion: apps/v1beta1
kind: Deployment
metadata:
  name: azure-vote-front
spec:
  replicas: 1
  template:
    metadata:
      labels:
        app: azure-vote-front
    spec:
      containers:
      - name: azure-vote-front
        image: microsoft/azure-vote-front:redis-v1
        ports:
        - containerPort: 80
        env:
        - name: REDIS
          value: "azure-vote-back"
```
__Service__
```
apiVersion: v1
kind: Service
metadata:
  name: azure-vote-front
spec:
  type: LoadBalancer
  ports:
  - port: 80
  selector:
    app: azure-vote-front
```
In the above example, we create a deployment named `azure-vote-front` with the label `app: azure-vote-front`. Afterwards we create a service named `azure-vote-front`, which references that deployment with the selector `app: azure-vote-front`.

Labels and selectors are not unique by design and multiple k8s resources can have the same label attached to them. Selector can specify labels that are equal (through = or ==) are not equal (through !=. Selectors can also specify sets of labels, e.g. `app in (web, db, backend)` or `app not in (monitoring, backup)`.

In addition to labels and selectors, k8 supports assigning arbitrary metada to resources through [annotations](https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/). In the following example, annotation is used to create a service with an Azure load balancer of the internal type:
```
apiVersion: v1
kind: Service
metadata:
  name: internal-app
  annotations:
    service.beta.kubernetes.io/azure-load-balancer-internal: "true"
spec:
  type: LoadBalancer
  ports:
  - port: 80
  selector:
    app: internal-app
```

### Create and configure basic Pods

A pod is the basic execution unit within k8s and can contain multiple containers in it. Within a pod, containers share networking and storage access. A pod is scheduled as a whole on one of the nodes in your cluster, meaning all containers in a pod will run on the same node. Multiple instances of a pod can be run across multiple cluster nodes.

By design, pods are ephemeral. They can be killed or moved to another node by the system, meaning any state that is not explicitely persisted can be lost. Typically, you won’t create individual pods directly; rather, you’ll create a deployment, which will create pods for you.

A simple (basic?) pod specification is the following:
```
apiVersion: v1
kind: Pod
metadata:
  name: basic-pod
spec:
  containers:
    - name: basic
      image: nginx
```

You can save this snippet of code in a `simplepod.yaml` file, and then deploy it in your kubernetes cluster with the following command:
```
kubectl apply -f simplepod.yaml
```

If you then do `kubectl get pods` to see the pod was created. To verify that nginx is running:

```
kubectl exec -it basic-pod /bin/bash
apt update
apt install curl -y
curl localhost
```

k8s supports specifying the way resources will be monitored, e.g. with _readinessProbes_ and _livenessProbes_. For resource as simple as pod, only _livenessProbes_ can be specifyed:

apiVersion: v1
kind: Pod
metadata:
  name: basic-pod
spec:
  containers:
    - name: basic
      image: nginx
      livenessProbe:
        httpGet:
          path: /
          port: 80
        initialDelaySeconds: 15
        timeoutSeconds: 1

`livenessProbe` can not be added to a live pod, another instance has to be created with this new definition: 
```
kubectl delete -f simplepod.yaml
kubectl apply -f simplepod.yaml
kubectl get pods --watch
```

Now open up a second terminal, and do the following:
```
kubectl exec -it basic-pod /bin/bash
mv /usr/share/nginx/html/index.html /usr/share/nginx/html/index.html.backup 
```
This last bit will make our livenessProbe fail. You will notice in the first terminal (where we are watching the pods in the cluster) that Kubernetes will restart our pod. In that restarted pod, we’ll have the original filesystem again (our move command will have been ‘undone’), and the livenessProbe will be succesfull again. If you want even more info on the restart of your pod, execute the following command:
```
kubectl describe pod/basic-pod
```

The output should look like this, indicating the failed probe and the pod restart:
```
Type     Reason     Age               From                                        Message
  ----     ------     ----              ----                                        -------
  Normal   Scheduled  62s               default-scheduler                           Successfully assigned default/basic-pod to aks-nodepool1-14406582-vmss000001
  Warning  Unhealthy  9s (x3 over 29s)  kubelet, aks-nodepool1-14406582-vmss000001  Liveness probe failed: HTTP probe failed with statuscode: 403
  Normal   Killing    9s                kubelet, aks-nodepool1-14406582-vmss000001  Container basic failed liveness probe, will be restarted
  Normal   Pulling    8s (x2 over 60s)  kubelet, aks-nodepool1-14406582-vmss000001  Pulling image "nginx"
  Normal   Pulled     7s (x2 over 58s)  kubelet, aks-nodepool1-14406582-vmss000001  Successfully pulled image "nginx"
  Normal   Created    6s (x2 over 58s)  kubelet, aks-nodepool1-14406582-vmss000001  Created container basic
  Normal   Started    6s (x2 over 58s)  kubelet, aks-nodepool1-14406582-vmss000001  Started container basic
```